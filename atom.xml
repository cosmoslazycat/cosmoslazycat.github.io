<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cosmoslazycat.github.io</id>
    <title>CosmosLazyCat的实验室</title>
    <updated>2021-07-17T16:47:55.039Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cosmoslazycat.github.io"/>
    <link rel="self" href="https://cosmoslazycat.github.io/atom.xml"/>
    <subtitle>Man Always Remember Love Because Of Romance Only</subtitle>
    <logo>https://cosmoslazycat.github.io/images/avatar.png</logo>
    <icon>https://cosmoslazycat.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, CosmosLazyCat的实验室</rights>
    <entry>
        <title type="html"><![CDATA[[blog](持续更新)Interesting Website！]]></title>
        <id>https://cosmoslazycat.github.io/post/tui-jian-interesting-blog/</id>
        <link href="https://cosmoslazycat.github.io/post/tui-jian-interesting-blog/">
        </link>
        <updated>2021-07-17T14:25:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="blog">BLOG</h2>
<p><a href="https://www.kawabangga.com/">卡瓦邦噶</a> - 捕蛇者说主播之一<br>
<a href="http://laker.me/blog/">一位进击的程序媛</a><br>
<a href="coolshell.cn">酷壳</a>  - 耗子叔的个人博客，我的启蒙人之一<br>
<a href="https://godbasin.github.io/front-end-playground/">被删的前端游乐场</a> - 一个努力学习的人<br>
<a href="https://www.tangshuang.net/">唐霜</a> - Robust播客的主理人</p>
<h2 id="podcast">Podcast</h2>
<p><a href="https://pythonhunter.org/">捕蛇者说</a> - 喜欢的播客和博客网站<br>
<a href="https://anobody.im/">阿乐杂货铺</a> - 一个在荷兰生活的前端程序媛<br>
<a href="https://www.tangshuang.net/fm">Robust: 程序员的TALK PLACE</a> - 内容和时长都比较硬核的播客<br>
<a href="https://frontendhappyhour.com/">Front End Happy Hour</a> - 内容如其名的播客</p>
<h2 id="website">WEBSITE</h2>
<p><a href="www.stackoverflow.com">stackoverflow</a> - 常用的提问和解惑网站<br>
<a href="www.freecodecamp.org">freecodecamp</a> - 我的启蒙网站之一<br>
<a href="www.codepen.io">codepen</a> - 很喜欢里面的一些前端设计<br>
<a href="www.github.com">github</a> - 用的不是很多，以后有能力会贡献自己的代码<br>
<a href="www.numerade.com">Numerade</a> - 一个专门为书籍上的问题解惑的网站<br>
<a href="https://teachyourselfcs.com/">teachyourselfcs</a>  - 我的启蒙网站之一<br>
<a href="www.youtube.com">youtube</a> - 常用的自学视频搜索网站<br>
<a href="https://www.yuque.com/zaotalk">前端早早聊</a> - 一个内容质量非常不错的国内前端分享频道（付费）<br>
<a href="www.fullstackopen.com">FullStackOpen</a> - 我的启蒙网站之一</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[转载]如何做一个有质量的技术分享]]></title>
        <id>https://cosmoslazycat.github.io/post/zhuan-zai-ru-he-zuo-yi-ge-you-zhi-liang-de-ji-zhu-fen-xiang/</id>
        <link href="https://cosmoslazycat.github.io/post/zhuan-zai-ru-he-zuo-yi-ge-you-zhi-liang-de-ji-zhu-fen-xiang/">
        </link>
        <updated>2021-07-13T07:02:29.000Z</updated>
        <content type="html"><![CDATA[<p>原文地址：https://coolshell.cn/articles/21589.html<br>
</br><br>
分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：1）分享内容的保鲜期是很长的，2）会被大范围的传递。我们团队内每周都在做技术分享，虽然分享的主题都很有价值，但是分享的质量参差不齐，所以，想写下这篇文章 。供大家参考。</p>
<p>首先，我们先扪心自问一下，我们自己觉得读到的好的技术文章是什么？我不知道大家的是什么，我个人认为的好的文章是下面这样的：</p>
<p>把复杂的问题讲解的很简单也很清楚。比如我高中时期读到这本1978年出版的《从一到无穷大》，用各种简单通俗通懂的话把各种复杂的科学知识讲的清清楚楚。还有看过的几本很好的书，一本是《Windows程序设计》，从一个hello world的程序开始一步一步教你Windows下的原生态编程。<br>
有各种各样的推导和方案的比较，让你知其然知其所以然。有了不同方案的比较，才可能让人有全面的认识。这个方面的经典作著是《Effective C++》。<br>
原理，为什么，思路，方法论会让人一通百通。这里面最经典的恐怕就是《十万个为什么》了，在计算机方面也有几本经典书，一本是《Unix编程艺术》、《设计模式》、《深入理解计算机系统》等书，以及《The C10K Problem》等很多技术论文。<br>
其实，从教科书，到专业书，再到论文，都有上面这些不错的特质。</p>
<p>所以，如果你想做一个好的技术分享的话，下面是我总结出来的，几个“要”和“不要”。</p>
<ul>
<li>先描述好一个问题。这样能够听众带入进来，如果这个问题是他们感同身受的，那是最好了。千万不要一上来就说What，或是直接冲进答案里。这样的分享是在灌输和填鸭。把Why说清楚，没有Why，直接谈What的技术分享，通常来说价值不大。</li>
<li>How比What重要。在讲How的时候，也就是如何解这个问题。</li>
<li>先要把问题模型说清楚，有了问题模型这个框框后，方案才有意义。</li>
<li>然后要有不同技术的比较。有了比较后，听众才会更相信你。</li>
<li>一定要有Best Practice或方法论总结，否则上不了档次的。也就是分享的重要收获。<br>
</br><br>
说明了这个模型就是：问题 –&gt; 方案 –&gt; 总结。这其中是有一定的心理学模型的，具体表现如下：</li>
<li>用问题来吸引受众，带着受众来一起思考</li>
<li>用问题模型来框住受众的思考范围，让受众聚焦</li>
<li>给出几种不同的解决方案，比较他们的优缺点，让受众有一种解决问题的参与感。</li>
<li>最后，给出最佳实践，方法论或套路，因为有了前三步的铺垫，受众欣然接受。</li>
<li>整个过程受众会有强烈的成长感和收获感。<br>
这里有几个示例，也是我在我司 MegaEase 内部的技术分享，供你参考（我个人的YouTube频道）</li>
</ul>
<p>技术分享：<a href="https://youtu.be/qB40kqhTyYM">Prometheus是怎么存储数据的（Youtube）</a></p>
<p>技术分享：<a href="https://youtu.be/VnbC5RG1fEo">Distributed Lock Manager（Youtube）</a></p>
<p>下面是我写在我们公司内的Knowledge Sharing中的Best Practice，供参考</p>
<h3 id="sharing-guideline">Sharing Guideline</h3>
<p>Please follow the following sharing protocols<br>
</br></p>
<h3 id="understand-sharing">Understand Sharing</h3>
<ul>
<li>Sharing is the hard way to learn knowledge. The presenter gains the biggest advantages. not audience. 分享是学习知识的最难的方式。分享者获得的好处最最多的，而不是观众。</li>
<li>Sharing can open the knowledge door for the audience, but you have to walk to knowledge by yourself. 分享可以为听众打开知识的大门，但你能不能获得知识还要靠你自己。<br>
</br></li>
</ul>
<h3 id="best-practices">Best Practices</h3>
<p>To perform a great sharing, please follow the below practices.</p>
<ul>
<li>
<p>Do not share a big topic, a small topic is better. A big topic could make the audience lose focus. Remember, Less is More!</p>
</li>
<li>
<p>Sharing time less than 60 mins is the best.</p>
</li>
<li>
<p>English language for slides is preferred.</p>
</li>
<li>
<p>While prepare the sharing contents, it’s better to discuss with the senior people to help you to see the whole picture, understand the good side and bad side, know what you don’t know … etc.</p>
</li>
<li>
<p>Strong Recommend Materials Outlines</p>
</li>
<li>
<p>What’s the Problem?</p>
</li>
<li>
<p>How to Solve the Problem?</p>
</li>
<li>
<p>The Best Solution or Practice.</p>
</li>
<li>
<p>The Mechanism, Key Techniques, and Source Code</p>
</li>
<li>
<p>Pros/Cons</p>
</li>
<li>
<p>References (Further reading)</p>
</li>
<li>
<p>For example, if you want to sharing a topic about Docker. the following outlines would be good one:</p>
<ul>
<li>What’s the major problems need to solve. (Provision, Environment, Isolation etc.)</li>
<li>The Alternative solutions. (Puppet/Chef/Ansible, VM, LXC etc.)</li>
<li>The Best Solution – Docker. Why?</li>
<li>Docker’s key techniques – image, cgroup, union fs, namespace…</li>
<li>Docker’s Pros/Cons</li>
<li>Further reading list.</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[转载][翻译]从源码中学习（阅读源码，初学者的有效成长方式）]]></title>
        <id>https://cosmoslazycat.github.io/post/zhuan-zai-fan-yi-cong-yuan-ma-zhong-xue-xi-yue-du-yuan-ma-chu-xue-zhe-de-you-xiao-cheng-chang-fang-shi/</id>
        <link href="https://cosmoslazycat.github.io/post/zhuan-zai-fan-yi-cong-yuan-ma-zhong-xue-xi-yue-du-yuan-ma-chu-xue-zhe-de-you-xiao-cheng-chang-fang-shi/">
        </link>
        <updated>2021-06-26T00:38:31.000Z</updated>
        <content type="html"><![CDATA[<p>原文： <a href="https://coderscat.com/learn-from-source-code/">Learn from Source Code (an Effective Way to Grow for Beginners)</a> ，原作者为Nick Mose 。</p>
<p>翻译者：<a href="https://boholder.github.io/blogs/learn-from-source-code/#">从源码中学习（阅读源码，初学者的有效成长方式）</a></p>
<h2 id="前言">前言</h2>
<p>上周我在和一位年轻程序员聊天时，他问到我：“如何阅读源码？”，我们讨论了一段时间，我还列举了几种有效阅读源码的方式。 然后他说：“你应该就这个话题写篇文章，这对初学者很有帮助，而且这种经验无法从书籍和教程中获得。” 那么开始吧，下面是我关于阅读源码的小技巧。</p>
<h2 id="为什么我们需要读源码">为什么我们需要读源码</h2>
<p>我们程序员每天都要和源码打交道。经过数年的学习，大多数程序员可以“写”代码，或者至少是拷贝并修改代码。 而且，我们教授编程的方式强调编写代码的艺术，而不是如何阅读代码。 当我说“阅读代码”，我是指有意地专门阅读代码。</p>
<p>众所周知，编程和写作有诸多相同之处。 唐纳德·克努特甚至引入了文学编程(literate programming) 编程范式。 编程与写作有相同的理念：表达我们的想法 。 还记得你在学校是怎么学习写作的吗？我们的写作能力来源于从小学开始直到现在的大量的文本阅读。 多年以来，我们阅读了不同难度的伟大作家的作品，并练习了多种写作技巧。</p>
<p>“如果你没时间读，你就没时间（或工具）写，就这么简单。” —— 斯蒂芬·金，《写作这回事：创作生涯回忆录》</p>
<p>正如斯蒂芬·金所观察到的那样，一个作家必须广泛而频繁地阅读，才能形成自己的声音， 并学会写出促使读者拿起书并痴读的句式和故事结构。 和读书一样，有意地阅读代码可以帮助程序员加速成长，尤其是对中级(intermediate)程序员而言。 这样做有三个好处。</p>
<h3 id="站在巨人的肩膀上">站在巨人的肩膀上</h3>
<p>我们从他人身上学习。优秀的源代码就像文学杰作，它不仅仅只提供了知识和信息，还提供了启迪。</p>
<p>通过浏览Linux内核、Redis、Nginx、Rails或其他著名项目， 你可以从全球范围的成千上万的顶级程序员那里汲取智慧。 在这些项目中可以找到无数的良好编程示例、编程范式选择、设计和架构。 向他人学习的另一个好处是能够避免常见的坑，大多数坑早已被他人踩过。</p>
<h3 id="解决困难问题">解决困难问题</h3>
<p>在你的职业生涯中，你终将会碰到谷歌都无法解决的问题。 如果你还没碰到过这种问题，这只是因为你编程的时间还不足够长 😃。 阅读源码是调查这类问题的好方法，也是学习新东西的好机会。</p>
<h3 id="扩展你的边界">扩展你的边界</h3>
<p>大多数程序员只在少数特别领域编过程。 一般而言，如果你不时常推自己一把，你的编程技能会维持在你同事间的平均水平。 不要满足于修补bug或在现有系统中添加琐碎特性的工作。 相反，你可以试着扩展到一个新的领域，持续尝试找到一个你在日常工作中接触不到、但你感兴趣的领域。 这将从整体上拓宽你对编程的理解。</p>
<h2 id="应该读什么样的源码">应该读什么样的源码</h2>
<p>综上，阅读源码是有益的。 那么下一个问题，有这么多优秀作品可供选择，我们该选择并阅读什么样的源码呢？ 你必须从选择目标开始。如果不在这个步骤上下点功夫，你从源码中学习的效果就会打折扣。 这里有一些典型场景：</p>
<p>当你想学习一门新语言。学新语言可不只是学会语法 。 不管怎样，阅读源码是一个非常有效的学习新语言的方式。我从rust-rosetta 项目中学到了很多Rust语言知识。Rosetta Code 是一个收集同一批通用任务在不同语言上的解决方案的项目，这是一个可用来学习新语言的有用资源。</p>
<p>当你想了解一个特殊的算法或实现。 例如，我们都会使用标准库中的sort函数，你有没有好奇过它是怎么实现的？ 或者当你要使用Redis中的Set结构，它是用什么数据结构实现的？ 为了解决这些疑惑，你只需要读源码中与之相关的实现部分，通常只有很少的文件或函数。</p>
<p>当你在特殊的框架中编程。这意味着你对该框架已经有了一定的经验， 这是个阅读一些框架本身的源码的好机会。 很显然，了解框架的源码有助于提高你对框架的理解。</p>
<p>当你想拓展进入新的领域，你可以阅读这个领域的经典著名的项目的源码。 比如说，如果你在做Web开发的工作，你对分布式系统感兴趣吗？ 如果你的答案是“是”而且你懂Golang，也许etcd 是你的选择。你想钻研操作系统的内部构成吗？那么也许xv6 是一个好的开始。我们处在一个许多优秀开源项目都托管在了Github的好时代，请试着寻找一些这种项目。</p>
<p>记住，选择与你当前的编程技能与知识水平相当的项目。 如果你选择了远超你当前技能水平的项目，最终你会感到沮丧。 读一些相对较小的项目，接着读更大的项目。 如果目前你不能理解某些特定的代码片段，这意味着你有个知识缺口(knowledge gap)。 把代码放到一边去，试着读一些相关的书、论文或其他文档，当你更有信心时再回来接着读代码。 我们总能在一个模式中取得进展：读（代码、书、论文），写，更多的读，更多的写。</p>
<h2 id="如何读源码">如何读源码</h2>
<p>《How to read a book》 是一本指导人进行明智地阅读的书。作为初学者，我们值得投入时间和精力去思考我们应该如何阅读代码。 阅读代码不是件容易的事。 光是阅读源码是不够的，你要试着去理解他人的设计和想法。</p>
<h3 id="预先准备">预先准备</h3>
<p>为了更有效率地阅读代码，你需要提前在手边准备这些东西：</p>
<p>一个你可以熟练使用的编辑器。你需要拥有快速搜索关键字或变量名的能力。 有时你需要查找函数的引用和定义。和你的编辑器相处融洽些。 为了更加有效率，试着学习仅使用键盘操作编辑器。 这会使你专注于代码而不受打扰（译：指额外思考编辑器操作）。</p>
<p>掌握基本的Git或其他版本控制工具的技能，这样你就能比较代码在版本间的差异。</p>
<p>与源码有关的文档。文档可以为你的阅读提供参考，尤其是设计文档、编码规范等文档。</p>
<p>具有一定的编程语言与设计模式的知识和经验。这对（阅读）大项目是强制性的。 如果你很了解一门编程语言，你也会了解关于源码组织与编程范式的最佳实践。 当然，这需要时间来积累。要有耐心。</p>
<h3 id="流程与技巧">流程与技巧</h3>
<p>阅读过程不是线性的。你不会就那么一个接一个地读源文件。 相反，大多数时候我们会从顶到底地阅读代码。 下面是一些更有效率阅读代码的小技巧：</p>
<h4 id="结合上下文阅读代码">结合上下文阅读代码</h4>
<p>当你阅读代码时，请持续提出问题。 例如，如果一个应用有缓存策略，一个好问题就是：如果键无效了会怎样？缓存中的值如何更新？ 带着这些问题阅读代码，就是结合上下文。或者说因为你有了一个目标，你会变得享受阅读的过程。 你甚至可以自己做一些假设，然后在代码中寻找验证。</p>
<p>你有点像侦探：你想发现代码的真相，代码的逻辑，代码是如何像故事一般上下流动的。</p>
<h4 id="把实例跑起来并与之交互">把实例跑起来并与之交互</h4>
<p>源码就像乐高积木，只是已经组装好了。 如果你想了解它们是怎么组装在一起的，你需要和它交互，有时甚至要把它拆开。 阅读同一模块的老版本同样有帮助。从Git中阅读版本差异，试着弄清楚特定的特性是如何实现的 （修改日志在这个场景很有用）。 举个例子，我发现Lua的第一个版本相当简单，这可以帮助我了解作者最初的设计理念。</p>
<p>Debug是另一种与代码交互的方式。试着在代码中加一些断点（或打印一些变量值）， 然后弄明白打印到控制台中的所有输出。</p>
<p>如果你对代码了解比较透彻了，试着对代码做一些修改，重新build并把它跑起来。 最简单的方式是试着调整配置项，去看不同配置的运行结果。 之后你可以试着添加一些细微的特性。 如果这些特性对其他人也有用，你应该把代码贡献到上游。</p>
<h4 id="了解数据结构间的关系">了解数据结构间的关系</h4>
<p>“糟糕的程序员担心代码，优秀的程序员担心数据结构和它们的关系。” -Linus Torvalds</p>
<p>数据结构是一个程序中最重要的元素。用笔或者你喜欢的其他工具画出数据结构间的关系。 这个图就是源码的映射。你会在阅读过程中时常参考这个图。一些工具比如scitools 可以用来生成UML类图。 （译：这个方法用在写代码中能节约翻Model声明文件的时间，推荐用纸笔，不占屏幕）</p>
<h4 id="了解模块间的依赖关系与边界">了解模块间的依赖关系与边界</h4>
<p>大项目中会包含许多模块，一个模块经常只拥有单一职责。 这有助于我们减少代码复杂度，在适当的层级上做抽象。 模块的接口是抽象的边界，我们可以一个接一个地阅读模块。 如果你在阅读一个使用Make构建的C/C++项目，Makefile是了解模块间如何组织的好切入点。</p>
<p>边界本身也很有用。优秀的代码组织得很好，变量名与函数名的命名风格体现着可读性。 你不需要阅读全部源文件，你可以忽略不重要的或你熟悉的部分。 如果你确定一个模块是仅仅是为了被解析而设计的(just designed for parsing)， 那么你已经大致了解了它的功能；那么你就可以跳过不读这个模块。 当然，这将大大节约时间。</p>
<h4 id="使用测试用例">使用测试用例</h4>
<p>测试用例也是帮助代码理解的一个很好的补充。测试用例就是文档。 当你在阅读一个类时，试着把对应的测试代码一起读了。 测试用例能帮你弄清一个类的接口，和该类的典型用法。 集成测试用例可以让你顺着走过程序的整体流程，适合输入一些特殊值并debug运行。</p>
<h4 id="点评">点评</h4>
<p>为什么不在花了不少时间阅读一个项目后，写一篇代码点评呢？就像写一篇书评一样。 你可以写下代码中好的和不好的部分，还可以记下你从中学到了什么。 攥写这类文章可以帮助你阐明自己的理解，也有助于其他人阅读源码。</p>
<h2 id="一些好书">一些好书</h2>
<p>我发现阅读代码是一个远超我想象的广泛话题。没有系统性训练该技能的方法。 总而言之，不断练习，找到你自己的方式。下面是一些帮助你提升代码阅读能力的好书：</p>
<ul>
<li>《Design Patterns: Elements of Reusable Object-Oriented Software》</li>
<li></li>
<li>《Clean Architecture: A Craftsman’s Guide to Software Structure and Design》</li>
<li></li>
<li>《How to Read a Book: The Classic Guide to Intelligent Reading》</li>
</ul>
<p>啊哈，这本书对程序员也很有用。</p>
<h2 id="译者的话">译者的话</h2>
<p>这篇文章是为苦于不知从何开始阅读陌生项目代码的人（包括我）准备的。 截止撰文时间为止，我认为这篇文章是在同话题中较为务实的一篇， 不仅包含理念，还包含不少具体可实践的建议，因此我想把它分享给更多人。 而且我想如果它有中文版本，愿意读下去的人会多一些，我也方便向周围的人分享，于是我向Nic申请了翻译权。 我把标题改了改，这样搜索“源码”“学习”、“阅读源码”都能搜到。</p>
<p>这篇文章对我而言，最大作用是帮我突破了“不需要有意地专门阅读代码”的心理障碍。 我一直以为既然“写代码的时间中十之六七都是花在读既有代码上”（语出《Clean Code》）， 就没必要再花时间专门读代码，我大错特错。</p>
<p>个人经验：驱动我“专门读代码”的最大动机是好奇心，和小孩拆小物件为了看内部构造差不多。 学习OO设计模式，我建议阅读《Head First 设计模式》 ，这本书超有趣，比四人帮那本删减了一些不常用的模式，但是你能轻松读下去。</p>
<p>阅读了解项目代码是参与（开源）项目的第一步，希望这篇文章能帮助你参与到心仪的项目中去。 这也可以帮助你在工作中了解同组同事的工作，而“了解同组同事的工作对工作有诸多潜在益处” 。 来吧，花点时间挑一个看上眼的项目（或者就读你手头的项目别人写的部分）， 找到你最感兴趣的功能，读一读它是怎么实现的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[分享]计算机学科有意思的比喻]]></title>
        <id>https://cosmoslazycat.github.io/post/fen-xiang-ji-suan-ji-xue-ke-you-yi-si-de-bi-yu/</id>
        <link href="https://cosmoslazycat.github.io/post/fen-xiang-ji-suan-ji-xue-ke-you-yi-si-de-bi-yu/">
        </link>
        <updated>2021-06-25T05:46:49.000Z</updated>
        <content type="html"><![CDATA[<p>原文：<a href="https://twitter.com/laixintao/status/1402663872561958915?s=20">https://twitter.com/laixintao/status/1402663872561958915?s=20</a></p>
<p>小时候喜欢哈利波特，后来觉得学习计算机就像在学习魔法一样。</p>
<ul>
<li>魔咒学 - 计算机组成原理和体系结构</li>
<li>树枝占卜学 - 机器学习</li>
<li>黑魔法防御术 - 信息安全技术</li>
<li>魔法理论 - 可计算理论</li>
<li>魔法史 - Unix发展史</li>
<li>草药学 - 数学</li>
<li>魔药学 - 算法和数据结构</li>
<li>变形学 - 数据库</li>
<li>飞行课 - 操作系统</li>
<li>咒语解析学 - 编译原理</li>
<li>猫头鹰：互联网</li>
<li>魔法杖：编程语言</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEWS]安全日报]]></title>
        <id>https://cosmoslazycat.github.io/post/news0706-an-quan-ri-bao/</id>
        <link href="https://cosmoslazycat.github.io/post/news0706-an-quan-ri-bao/">
        </link>
        <updated>2021-06-24T15:09:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="信安守则">信安守则：</h1>
<p>1，学安全的第一步是先学《网络安全法》。<br>
2，未经授权的渗透测试，以及在渗透测试中超越边界的任何行为都视为违法<br>
3，只做有双方背书的书面授权的安全测试</p>
<p>此系列博文不分享任何漏洞编号、POC代码、使用教程，旨在提醒自己注意代码安全问题。</p>
<p>一、Saltstack 任意文件写入漏洞<br>
1，说明：saltstack (<a href="http://www.saltstack.com">http://www.saltstack.com</a>) 是使用python开发的一款服务器基础架构集中化管理平台,开始于2011年,具备配置和管理、远程执行、监控等功能。</p>
<p>2，漏洞信息：saltstack在后台的一些配置文件修改编辑等处，程序开发过程中将这些配置信息未做好过滤就保存到了文件中，导致攻击者可以在文件中写入任意的内容.</p>
<p>3，防范手段:</p>
<ul>
<li>尽量避免在可执行文件中保存字符串内容。</li>
<li>对写入的字符串进行完美的过滤。</li>
</ul>
<p>影响版本：</p>
<ul>
<li>&lt;3002.5</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEWS]安全日报]]></title>
        <id>https://cosmoslazycat.github.io/post/newsan-quan-ri-bao/</id>
        <link href="https://cosmoslazycat.github.io/post/newsan-quan-ri-bao/">
        </link>
        <updated>2021-06-24T13:23:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="信安守则">信安守则：</h1>
<p>1，学安全的第一步是先学《网络安全法》。<br>
2，未经授权的渗透测试，以及在渗透测试中超越边界的任何行为都视为违法<br>
3，只做有双方背书的书面授权的安全测试</p>
<p>此系列博文不分享任何漏洞编号、POC代码、使用教程，旨在提醒自己注意代码安全问题。</p>
<h3 id="一-lanproxy-目录遍历漏洞directory-traversal">一、Lanproxy 目录遍历漏洞（Directory traversal）</h3>
<p>1，说明：lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面...）。</p>
<p>2，漏洞信息：攻击者能通过构造某些信息并发送GET请求，在得到响应后，能在配置文件中读取到账号密码</p>
<p>3，防范手段（前端/后端）：</p>
<ul>
<li>
<p>过滤../和~/目录跳转符、%00字符截断符、dir命令等；</p>
</li>
<li>
<p>合理配置Web服务器的目录权限；（最有效的方式）</p>
</li>
<li>
<p>隐藏内部相关配置细节，以免程序出错时显示出来；</p>
</li>
<li>
<p>对用户提交过来的文件名进行硬编码或者统一编码；</p>
</li>
<li>
<p>对文件后缀进行白名单控制，对包含了恶意的符号或者空字节进行拒绝。</p>
</li>
</ul>
<p>影响版本</p>
<ul>
<li>Lanproxy 0.1</li>
</ul>
<h3 id="二-gitlab-graphql邮箱信息泄露漏洞">二、GitLab Graphql邮箱信息泄露漏洞</h3>
<p>1，说明:GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言）。GitLab 为此专门提供了GraphQL的API.</p>
<p>2，漏洞信息：Gitlab本身不允许获取账号邮箱信息，这里通过调用 Graphql 的某一信息查询造成了邮箱泄露漏洞，但利用该漏洞需要有账号用户名，如果没有，则无法获取邮箱信息。不过通过构造某一语句作为请求发送，可一次性返回所有的用户名和邮箱。</p>
<p>影响版本：</p>
<ul>
<li>GitLab 13.4 - 13.6.2</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEWS]安全日报]]></title>
        <id>https://cosmoslazycat.github.io/post/new73-an-quan-ri-bao/</id>
        <link href="https://cosmoslazycat.github.io/post/new73-an-quan-ri-bao/">
        </link>
        <updated>2021-06-24T10:20:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="信安守则">信安守则：</h1>
<p>1，学安全的第一步是先学《网络安全法》。<br>
2，未经授权的渗透测试，以及在渗透测试中超越边界的任何行为都视为违法<br>
3，只做有双方背书的书面授权的安全测试</p>
<p>此系列博文不分享任何漏洞编号、POC代码、使用教程，旨在提醒自己注意代码安全问题。</p>
<h3 id="一-veryfitpro加密漏洞">一、VeryFitPro加密漏洞</h3>
<p>1，说明：VeryFitPro是中国深圳市爱都科技有限公司的一款功能强大的健康管理软件,需要搭配同品牌智能手环使用,使用app用戶可以实时查看行走步数、消耗卡路里、睡眠质量等信息。</p>
<p>2，漏洞信息：VeryFitPro 中存在加密漏洞问题，该漏洞源于允许通过明文HTTP与后端API进行所有通信。攻击者可通过该漏洞获得用戶敏感信息。以下产品及版本受到影响：<code>VeryFitPro For Android 3.2.8</code>。</p>
<h3 id="二-overlayfs-权限提升漏洞">二、Overlayfs 权限提升漏洞</h3>
<p>1，说明：Overlayfs是Linux系统中的一种堆叠文件系统，它依赖并建立在其它的文件系统之上（例如ext4fs和xfs等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。</p>
<p>2，漏洞信息：OverlayFS漏洞允许Ubuntu下的本地用戶获得root权限。 Linux內核中overlayfs文件系统中的Ubuntu特定问题，在该问题中，它未正确验证关于用户名称空间的文件系统功能的应用程序。由于Ubuntu附带了一個允许非特权的overlayfs挂载的补丁，因此本地攻击者可以使用它來获得更高的权限。</p>
<h4 id="受影响版本">受影响版本：</h4>
<ul>
<li>Ubuntu 20.10</li>
<li>Ubuntu 20.04 LTS</li>
<li>Ubuntu 18.04 LTS</li>
<li>Ubuntu 16.04 LTS</li>
<li>Ubuntu 14.04 ESM</li>
</ul>
<h3 id="三-openssl拒绝服务漏洞">三、OpenSSL拒绝服务漏洞</h3>
<p>1，说明：OpenSSL是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。同时也是一个开放源代码的软件库包，而应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。</p>
<p>2，漏洞信息：openssl 版本低于 1.1.1-k，默认配置下使用 openssl 的软件（包括 nginx 和 trojan-gfw 等），恶意构造的请求可以让服务端崩溃。</p>
<h4 id="受影响版本-2">受影响版本：</h4>
<ul>
<li>&lt; 1.1.1-k</li>
</ul>
<h3 id="每日鸡汤">每日鸡汤</h3>
<pre><code>成事和成功，永远不是外界的环境和他人推动你走，只能靠你发挥主动。
什么城市、公司、学校、老师、同学、上司都是次要的。坚持自学、额外努力，主动思考、注重方法才重要。
一直保持自学和阅读习惯，保持有问题多搜索多查资料自己搞懂的习惯，一直保持主动思考的习惯。对任何专业、工作，都要如此。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[blog]Gridea主题修改]]></title>
        <id>https://cosmoslazycat.github.io/post/bloggridea-zhu-ti-xiu-gai/</id>
        <link href="https://cosmoslazycat.github.io/post/bloggridea-zhu-ti-xiu-gai/">
        </link>
        <updated>2021-06-24T06:39:21.000Z</updated>
        <content type="html"><![CDATA[<p>作者原主题购买： <a href="https://mianbaoduo.com/o/bread/YpWYlJ0=">https://mianbaoduo.com/o/bread/YpWYlJ0=</a></p>
<h2 id="一-改动前">一、改动前</h2>
<figure data-type="image" tabindex="1"><img src="https://cosmoslazycat.github.io/post-images/1625812792694.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://cosmoslazycat.github.io/post-images/1625812811980.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://cosmoslazycat.github.io/post-images/1625812821711.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://cosmoslazycat.github.io/post-images/1625812965629.png" alt="" loading="lazy"></figure>
<h2 id="二-改动后">二、改动后</h2>
<figure data-type="image" tabindex="5"><img src="https://cosmoslazycat.github.io/post-images/1625896665955.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://cosmoslazycat.github.io/post-images/1625896675520.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://cosmoslazycat.github.io/post-images/1625896683796.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://cosmoslazycat.github.io/post-images/1625896691340.png" alt="" loading="lazy"></figure>
<h2 id="总结">总结</h2>
<p>改成自己喜欢的样子，确实增加了不少写博客的兴趣，努力更新博客！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[CSS]flex布局]]></title>
        <id>https://cosmoslazycat.github.io/post/cssflex-bu-ju/</id>
        <link href="https://cosmoslazycat.github.io/post/cssflex-bu-ju/">
        </link>
        <updated>2021-06-24T06:24:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-创建flex布局">一、创建flex布局</h2>
<h3 id="1-区别">1, 区别</h3>
<p>div（块状元素）</p>
<pre><code>display:flex;
</code></pre>
<p>span（内联元素)</p>
<pre><code>display:inline-flex;
</code></pre>
<h3 id="2作用区域">2，作用区域</h3>
<table>
<thead>
<tr>
<th>作用在flex容器(container)</th>
<th>作用在flex子项(item)</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-direction</td>
<td>order</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>flex-grow</td>
</tr>
<tr>
<td>flex-flow</td>
<td>flex-shrink</td>
</tr>
<tr>
<td>justify-content</td>
<td>flex-basis</td>
</tr>
<tr>
<td>align-item</td>
<td>flex</td>
</tr>
<tr>
<td>align-content</td>
<td>align-self</td>
</tr>
</tbody>
</table>
<h2 id="二-详细">二、详细</h2>
<h3 id="作用在flex容器上的属性">作用在flex容器上的属性</h3>
<h4 id="1flex-direction">1，flex-direction</h4>
<p>row和row-reverse<br>
column和column-reverse<br>
<img src="https://cosmoslazycat.github.io/post-images/1625811948582.svg" alt="" loading="lazy"></p>
<p>2，flex-wrap<br>
<img src="https://cosmoslazycat.github.io/post-images/1625811974514.svg" alt="" loading="lazy"></p>
<pre><code>.container {
  flex-wrap: nowrap | wrap | wrap-reverse;
}
</code></pre>
<h4 id="3flex-flow">3，flex-flow</h4>
<pre><code>.container {
  flex-flow: column wrap;
}
</code></pre>
<h4 id="4justify-content">4，justify-content</h4>
<figure data-type="image" tabindex="1"><img src="https://cosmoslazycat.github.io/post-images/1625811996366.svg" alt="" loading="lazy"></figure>
<pre><code>.container {
  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;
}
</code></pre>
<h4 id="5-align-items">5, align-items</h4>
<figure data-type="image" tabindex="2"><img src="https://cosmoslazycat.github.io/post-images/1625812008548.svg" alt="" loading="lazy"></figure>
<pre><code>.container {
  align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;
}
</code></pre>
<h4 id="6-align-content">6, align-content</h4>
<figure data-type="image" tabindex="3"><img src="https://cosmoslazycat.github.io/post-images/1625812021771.svg" alt="" loading="lazy"></figure>
<pre><code>.container {
  align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;
}
</code></pre>
<h3 id="作用在flex子项item上的属性">作用在flex子项(item)上的属性</h3>
<h4 id="1-order">1. order</h4>
<figure data-type="image" tabindex="4"><img src="https://cosmoslazycat.github.io/post-images/1625812032539.svg" alt="" loading="lazy"></figure>
<pre><code class="language-css">.item {
  order: 5; /* 默认值为 0 */
}
</code></pre>
<h4 id="2-flex-grow">2. flex-grow</h4>
<figure data-type="image" tabindex="5"><img src="https://cosmoslazycat.github.io/post-images/1625812042359.svg" alt="" loading="lazy"></figure>
<pre><code class="language-css">.item {
  flex-grow: 4; /* default 0 */
}
</code></pre>
<h4 id="3-flex-shrink">3. flex-shrink</h4>
<pre><code class="language-css">.item {
  flex-shrink: 3; /* default 1 */
}
</code></pre>
<h4 id="4-flex-basis">4. flex-basis</h4>
<pre><code class="language-css">.item {
  flex-basis:  | auto; /* 默认值为 auto */
}
</code></pre>
<h4 id="5-flex">5. flex</h4>
<pre><code class="language-css">.item {
  flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]
}
</code></pre>
<h4 id="6-align-self">6. align-self</h4>
<figure data-type="image" tabindex="6"><img src="https://cosmoslazycat.github.io/post-images/1625812062868.svg" alt="" loading="lazy"></figure>
<pre><code>.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
</code></pre>
<h3 id="三-实际运用">三、实际运用</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[CSS]css实现禁止用户拖拽元素]]></title>
        <id>https://cosmoslazycat.github.io/post/csscss-shi-xian-jin-zhi-yong-hu-tuo-zhuai-yuan-su/</id>
        <link href="https://cosmoslazycat.github.io/post/csscss-shi-xian-jin-zhi-yong-hu-tuo-zhuai-yuan-su/">
        </link>
        <updated>2021-06-23T23:16:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-用户行为相关属性">一、用户行为相关属性</h3>
<p><code>user-select</code></p>
<p><code>user-modefy</code></p>
<p><code>user-drag</code></p>
<h3 id="二-示例">二、示例</h3>
<h4 id="1通过user-drag限制用户拖拽元素">1，通过user-drag限制用户拖拽元素</h4>
<p>HTML</p>
<pre><code>&lt;img src=&quot;xxx.jpg&quot; class=&quot;user-drag&quot;&gt;
</code></pre>
<p>CSS</p>
<pre><code>.user-drag {
	-webkit-user-drag: none;
}
</code></pre>
<h5 id="兼容性httpscaniusecomsearch-webkit-user-drag">兼容性（<a href="https://caniuse.com/?search=-webkit-user-drag">https://caniuse.com/?search=-webkit-user-drag</a>）</h5>
<figure data-type="image" tabindex="1"><img src="https://cosmoslazycat.github.io/post-images/1625786453666.png" alt="" loading="lazy"></figure>
<p>解读：IE不支持，chrome仅支持部分功能，移动端不支持</p>
<h4 id="2html-draggable属性">2，HTML <code>draggable</code>属性</h4>
<pre><code>&lt;img src=&quot;xxx.jpg&quot; draggable=&quot;true&quot;&gt;  // 可拖拽

&lt;img src=&quot;xxx.jpg&quot; draggable=&quot;false&quot;&gt;  //不可拖拽
</code></pre>
<h5 id="兼容性">兼容性</h5>
<figure data-type="image" tabindex="2"><img src="https://cosmoslazycat.github.io/post-images/1625786294969.png" alt="" loading="lazy"></figure>
<p>解读：兼容性优秀，移动端全部支持，IE10-11浏览器也支持</p>
<h3 id="总结">总结</h3>
<p>在处理禁止用户使用拖拽的场景时，优先使用HTML<code>draggable</code></p>
]]></content>
    </entry>
</feed>