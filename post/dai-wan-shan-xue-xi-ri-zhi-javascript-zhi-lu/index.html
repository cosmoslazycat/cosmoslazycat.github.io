<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>（待完善）[学习日志]JavaScript之旅 - CosmosLazyCat的宇宙</title>
<link rel="shortcut icon" href="https://cosmoslazycat.github.io/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://cosmoslazycat.github.io/media/css/tailwind.css">
<link rel="stylesheet" href="https://cosmoslazycat.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="（待完善）[学习日志]JavaScript之旅 - CosmosLazyCat的宇宙 - Atom Feed" href="https://cosmoslazycat.github.io/atom.xml">

    

  <meta name="description" content="
JavaScript排错
1，Error()
var err = new Error(&#39;Wrong!&#39;);
err.message // wrong!
err.name
err.stack


message：错误提示信息
name：错误..." />
  <meta property="og:title" content="（待完善）[学习日志]JavaScript之旅 - CosmosLazyCat的宇宙">
  <meta property="og:description" content="
JavaScript排错
1，Error()
var err = new Error(&#39;Wrong!&#39;);
err.message // wrong!
err.name
err.stack


message：错误提示信息
name：错误..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://cosmoslazycat.github.io/post/dai-wan-shan-xue-xi-ri-zhi-javascript-zhi-lu/" />
  <meta property="og:image" content="https://cosmoslazycat.github.io/post-images/dai-wan-shan-xue-xi-ri-zhi-javascript-zhi-lu.jpg">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="（待完善）[学习日志]JavaScript之旅 - CosmosLazyCat的宇宙">
  <meta name="twitter:description" content="
JavaScript排错
1，Error()
var err = new Error(&#39;Wrong!&#39;);
err.message // wrong!
err.name
err.stack


message：错误提示信息
name：错误...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://cosmoslazycat.github.io/post/dai-wan-shan-xue-xi-ri-zhi-javascript-zhi-lu/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  

  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://cosmoslazycat.github.io" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      CosmosLazyCat的宇宙
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          （待完善）[学习日志]JavaScript之旅
        </h1>
        
          <img src="https://cosmoslazycat.github.io/post-images/dai-wan-shan-xue-xi-ri-zhi-javascript-zhi-lu.jpg" alt="（待完善）[学习日志]JavaScript之旅" class="block w-full mb-8">
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2021-07-01 · 20 min read</div>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <figure data-type="image" tabindex="1"><img src="https://cosmoslazycat.github.io/post-images/1625141677751.jpg" alt="" loading="lazy"></figure>
<h3 id="javascript排错">JavaScript排错</h3>
<p>1，Error()</p>
<pre><code>var err = new Error('Wrong!');
err.message // wrong!
err.name
err.stack
</code></pre>
<ul>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p>2, SyntaxError 对象</p>
<p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>
<p>错误场景：</p>
<p>​	变量名错误    // Uncaught SyntaxError: Invalid or unexpected token</p>
<p>​	缺少括号     // Uncaught SyntaxError: Unexpected string</p>
<p>3, ReferenceError 对象</p>
<p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>
<p>错误场景：</p>
<p>​	引用一个不存在的变量时发生的错误。</p>
<p>​	将一个值分配给无法分配的对象，比如对函数的运行结果赋值</p>
<p>4，<code>RangeError</code>对象是一个值超出有效范围时发生的错误</p>
<p>数组长度为负数     // Uncaught RangeError: Invalid array length</p>
<p><code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值</p>
<p>5，<code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。</p>
<p>对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。 // Uncaught TypeError: 123 is not a constructor</p>
<p>调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。  // Uncaught TypeError: obj.unknownMethod is not a function</p>
<p>如何查看这些错误？</p>
<p>添加断点</p>
<pre><code>var err1 = new Error('出错了！');
var err2 = new RangeError('出错了，变量超出有效范围！');
var err3 = new TypeError('出错了，变量类型无效！');

err1.message // &quot;出错了！&quot;
err2.message // &quot;出错了，变量超出有效范围！&quot;
err3.message // &quot;出错了，变量类型无效！&quot;
</code></pre>
<p>如何打断点</p>
<p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>
<pre><code>var x = -1;

if (x &lt;= 0) {
  throw new Error('x 必须为正数');
}
// Un
</code></pre>
<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>
<p><code>try...catch</code> 结构</p>
<p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>
<pre><code>try {
  throw new Error('出错了!');
} catch (e) {
  console.log(e.name + &quot;: &quot; + e.message);
  console.log(e.stack);
}
// Error: 出错了!
//   at &lt;anonymous&gt;:3:9
//   ...
</code></pre>
<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>
<pre><code>try {
  f();
} catch(e) {
  // 处理错误
}
</code></pre>
<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>
<pre><code>try {
  throw &quot;出错了&quot;;
} catch (e) {
  console.log(111);
}
console.log(222);
// 111
// 222
</code></pre>
<p><code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>
<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>
<pre><code>try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.log(e.name + &quot;: &quot; + e.message);
  } else if (e instanceof RangeError) {
    console.log(e.name + &quot;: &quot; + e.message);
  }
  // ...
}
</code></pre>
<h3 id="符号说明">符号说明</h3>
<p><code>()</code>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。</p>
<pre><code>// 圆括号表示函数的调用
console.log('abc');

// 圆括号表示表达式的组合
(1 + 2) * 3
</code></pre>
<p>规范</p>
<pre><code>表示函数调用时，函数名与左括号之间没有空格。

表示函数定义时，函数名与左括号之间没有空格。

其他情况时，前面位置的语法元素与左括号之间，都有一个空格。
</code></pre>
<p>变量符号</p>
<p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p>
<p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>。</p>
<ul>
<li>所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</li>
<li>不要使用<code>with</code>语句。</li>
<li>建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）。</li>
<li>建议不要将不同目的的语句，合并成一行。</li>
<li>所有的<code>++</code>运算符都可以用<code>+= 1</code>代替。</li>
<li>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替</li>
<li>建议<code>switch...case</code>结构可以用对象结构代替。</li>
</ul>
<p>重构switch方法</p>
<pre><code>function doAction(action) {
  switch (action) {
    case 'hack':
      return 'hack';
    case 'slash':
      return 'slash';
    case 'run':
      return 'run';
    default:
      throw new Error('Invalid action.');
  }
}
</code></pre>
<p>重构</p>
<pre><code>function doAction(action) {
  var actions = {
    'hack': function () {
      return 'hack';
    },
    'slash': function () {
      return 'slash';
    },
    'run': function () {
      return 'run';
    }
  };

  if (typeof actions[action] !== 'function') {
    throw new Error('Invalid action.');
  }

  return actions[action]();
}
</code></pre>
<h3 id="console">console</h3>
<p>常用方法</p>
<p><code>count</code>方法用于计数，输出它被调用了多少次。</p>
<pre><code>function greet(user) {
  console.count();
  return 'hi ' + user;
}

greet('bob')
//  : 1
// &quot;hi bob&quot;

greet('alice')
//  : 2
// &quot;hi alice&quot;

greet('bob')
//  : 3
// &quot;hi bob&quot;
</code></pre>
<p>检查对象</p>
<p><code>console.dir()</code>，<code>console.dirxml()</code></p>
<pre><code>console.log({f1: 'foo', f2: 'bar'})
// Object {f1: &quot;foo&quot;, f2: &quot;bar&quot;}

console.dir({f1: 'foo', f2: 'bar'})
// Object
//   f1: &quot;foo&quot;
//   f2: &quot;bar&quot;
//   __proto__: Object
</code></pre>
<p>打断点</p>
<p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p>
<pre><code>console.assert(false, '判断条件不成立')
// Assertion failed: 判断条件不成立

// 相当于
try {
  if (!false) {
    throw new Error('判断条件不成立');
  }
} catch(e) {
  console.error(e);
}
</code></pre>
<p>代码计时</p>
<p><code>console.time()</code>，<code>console.timeEnd()</code></p>
<pre><code>console.time('Array initialize');

var array= new Array(1000000);
for (var i = array.length - 1; i &gt;= 0; i--) {
  array[i] = new Object();
};

console.timeEnd('Array initialize');
// Array initialize: 1914.481ms
</code></pre>
<p>代码查错</p>
<p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>
<pre><code>console.trace()
// console.trace()
//   (anonymous function)
//   InjectedScript._evaluateOn
//   InjectedScript._evaluateAndWrap
//   InjectedScript.evaluate
</code></pre>
<p><code>debugger 语句</code></p>
<p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>
<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>
<pre><code>for(var i = 0; i &lt; 5; i++){
  console.log(i);
  if (i === 2) debugger;
}
</code></pre>
<h3 id="object">Object</h3>
<p><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象</p>
<p>方法</p>
<p>属性描述对象</p>
<pre><code>{
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false,
  get: undefined,
  set: undefined
}
</code></pre>
<pre><code>value

value是该属性的属性值，默认为undefined。

（2）writable

writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。

（3）enumerable

enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。

（4）configurable

configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。

（5）get

get是一个函数，表示该属性的取值函数（getter），默认为undefined。

（6）set

set是一个函数，表示该属性的存值函数（setter），默认为undefined。
</code></pre>
<p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</p>
<pre><code>var obj = { p: 'a' };

Object.getOwnPropertyDescriptor(obj, 'p')
// Object { value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
</code></pre>
<p>注意，<code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性。</p>
<h4 id="对象的拷贝">对象的拷贝</h4>
<p>我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。</p>
<pre><code>var extend = function (to, from) {
  for (var property in from) {
    to[property] = from[property];
  }

  return to;
}

extend({}, {
  a: 1
})
// {a: 1}
</code></pre>
<p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值</p>
<pre><code>extend({}, {
  get a() { return 1 }
})
// {a: 1}
</code></pre>
<p>为了解决这个问题，我们可以通过<code>Object.defineProperty</code>方法来拷贝属性。</p>
<pre><code>var extend = function (to, from) {
  for (var property in from) {
    if (!from.hasOwnProperty(property)) continue;
    Object.defineProperty(
      to,
      property,
      Object.getOwnPropertyDescriptor(from, property)
    );
  }

  return to;
}

extend({}, { get a(){ return 1 } })
// { get a(){ return 1 } })
</code></pre>
<p>上面代码中，<code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象。</p>
<h4 id="控制对象状态">控制对象状态</h4>
<p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p>
<p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p>
<pre><code>var obj = new Object();
Object.preventExtensions(obj);

Object.defineProperty(obj, 'p', {
  value: 'hello'
});
// TypeError: Cannot define property:p, object is not extensible.

obj.p = 1;
obj.p // undefined
</code></pre>
<p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了。</p>
<p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性。</p>
<pre><code>var obj = new Object();

Object.isExtensible(obj) // true
Object.preventExtensions(obj);
Object.isExtensible(obj) // false上面代码中，对obj对象使用Object.preventExtensions方法以后，再使用Object.isExtensible方法，返回false，表示已经不能添加新属性了。
</code></pre>
<p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了。</p>
<p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。</p>
<pre><code>var obj = { p: 'hello' };
Object.seal(obj);

delete obj.p;
obj.p // &quot;hello&quot;

obj.x = 'world';
obj.x // undefined
</code></pre>
<p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了。</p>
<p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</p>
<pre><code>var obj = {
  p: 'a'
};

// seal方法之前
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

Object.seal(obj);

// seal方法之后
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: false
// }

Object.defineProperty(obj, 'p', {
  enumerable: false
})
// TypeError: Cannot redefine property: p
</code></pre>
<p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错。</p>
<p><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值。</p>
<pre><code>var obj = { p: 'a' };
Object.seal(obj);
obj.p = 'b';
obj.p // 'b'
</code></pre>
<p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定。</p>
<p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p>
<pre><code>var obj = { p: 'a' };

Object.seal(obj);
Object.isSealed(obj) // true
</code></pre>
<p>这时，<code>Object.isExtensible</code>方法也返回<code>false</code>。</p>
<pre><code>var obj = { p: 'a' };

Object.seal(obj);
Object.isExtensible(obj) // false
</code></pre>
<p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);

obj.p = 'world';
obj.p // &quot;hello&quot;

obj.t = 'hello';
obj.t // undefined

delete obj.p // false
obj.p // &quot;hello&quot;
</code></pre>
<p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。</p>
<p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);
Object.isFrozen(obj) // true
</code></pre>
<p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);

Object.isSealed(obj) // true
Object.isExtensible(obj) // false
</code></pre>
<p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);

if (!Object.isFrozen(obj)) {
  obj.p = 'world';
}
</code></pre>
<p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了。</p>
<h3 id="构造函数">构造函数</h3>
<p><code>Array</code>是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<pre><code>var arr = new Array(2);
arr.length // 2
arr // [ empty x 2 ]
</code></pre>
<p><code>Array()</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>
<pre><code>// bad
var arr = new Array(1, 2);

// good
var arr = [1, 2];
</code></pre>
<p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足。</p>
<pre><code>var arr = [1, 2, 3];

typeof arr // &quot;object&quot;
Array.isArray(arr) // true
</code></pre>
<p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组。</p>
<p><code>push</code>方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<pre><code>var arr = [];

arr.push(1) // 1
arr.push('a') // 2
arr.push(true, {}) // 4
arr // [1, 'a', true, {}]
</code></pre>
<p>上面代码使用<code>push</code>方法，往数组中添加了四个成员。</p>
<p><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<pre><code>var arr = ['a', 'b', 'c'];

arr.pop() // 'c'
arr // ['a', 'b']
</code></pre>
<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</p>
<pre><code>var arr = [];
arr.push(1, 2);
arr.push(3);
arr.pop();
arr // [1, 2]
</code></pre>
<p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组。</p>
<ul>
<li><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</li>
<li>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象。</li>
<li><code>concat</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</li>
<li><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</li>
<li><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变。<code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</li>
<li><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</li>
<li><code>map()</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</li>
<li><code>forEach()</code>方法与<code>map()</code>方法很相似，也是对数组的所有成员依次执行参数函数。</li>
<li><code>filter()</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</li>
<li><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</li>
<li><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</li>
<li><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</li>
</ul>
<h3 id="正则表达式">正则表达式</h3>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<pre><code>var regex = /xyz/;
</code></pre>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<pre><code>var regex = new RegExp('xyz');
</code></pre>
<h4 id="匹配规则"><a href="https://wangdoc.com/javascript/stdlib/regexp.html#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99">匹配规则</a></h4>
<p>字面量字符和元字符</p>
<p><code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<pre><code>/dog/.test('old dog') // true
</code></pre>
<p><code>元字符</code></p>
<p><strong>点字符（.)</strong></p>
<p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<pre><code>/c.t/
</code></pre>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code></p>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<pre><code>// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false
</code></pre>
<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<pre><code>/11|22/.test('911') // true
</code></pre>
<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p>多个选择符可以联合使用。</p>
<pre><code>// 匹配fred、barney、betty之中的一个
/fred|barney|betty/
</code></pre>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<pre><code>/a( |\t)b/.test('a\tb') // true
</code></pre>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文解释。</p>
<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<h3 id="json对象">JSON对象</h3>
<p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式</p>
<p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值</p>
<p>以下都是合法的 JSON。</p>
<pre><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]

{ &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 }

{&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] }

[ { &quot;name&quot;: &quot;张三&quot;}, {&quot;name&quot;: &quot;李四&quot;} ]
</code></pre>
<p>以下都是不合法的 JSON。</p>
<pre><code>{ name: &quot;张三&quot;, 'age': 32 }  // 属性名必须使用双引号

[32, 64, 128, 0xFFF] // 不能使用十六进制值

{ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined } // 不能使用 undefined

{ &quot;name&quot;: &quot;张三&quot;,
  &quot;birthday&quot;: new Date('Fri, 26 Aug 2011 07:13:10 GMT'),
  &quot;getName&quot;: function () {
      return this.name;
  }
} // 属性值不能使用函数和日期对象
</code></pre>
<p>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值。</p>
<p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>。</p>
<h3 id="面向对象">面向对象</h3>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#javascript%E6%8E%92%E9%94%99">JavaScript排错</a></li>
<li><a href="#%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">符号说明</a></li>
<li><a href="#console">console</a></li>
<li><a href="#object">Object</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D">对象的拷贝</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81">控制对象状态</a></li>
</ul>
</li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>
<ul>
<li><a href="#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99">匹配规则</a></li>
</ul>
</li>
<li><a href="#json%E5%AF%B9%E8%B1%A1">JSON对象</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://cosmoslazycat.github.io/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
  
</body>

</html>