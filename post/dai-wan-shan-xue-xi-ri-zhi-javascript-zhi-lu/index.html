<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>（待完善）[学习日志]JavaScript之旅 | Gridea</title>
<link rel="shortcut icon" href="https://cosmoslazycat.github.io/favicon.ico?v=1625209675010">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cosmoslazycat.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="（待完善）[学习日志]JavaScript之旅 | Gridea - Atom Feed" href="https://cosmoslazycat.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
JavaScript排错
1，Error()
var err = new Error('Wrong!');
err.message // wrong!
err.name
err.stack


message：错误提示信息
name：错误..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://cosmoslazycat.github.io">
  <img class="avatar" src="https://cosmoslazycat.github.io/images/avatar.png?v=1625209675010" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="github.com/cosmoslazycat" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              （待完善）[学习日志]JavaScript之旅
            </h2>
            <div class="post-info">
              <span>
                2021-07-01
              </span>
              <span>
                20 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://cosmoslazycat.github.io/post-images/dai-wan-shan-xue-xi-ri-zhi-javascript-zhi-lu.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <figure data-type="image" tabindex="1"><img src="https://cosmoslazycat.github.io/post-images/1625141677751.jpg" alt="" loading="lazy"></figure>
<h3 id="javascript排错">JavaScript排错</h3>
<p>1，Error()</p>
<pre><code>var err = new Error('Wrong!');
err.message // wrong!
err.name
err.stack
</code></pre>
<ul>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p>2, SyntaxError 对象</p>
<p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>
<p>错误场景：</p>
<p>​	变量名错误    // Uncaught SyntaxError: Invalid or unexpected token</p>
<p>​	缺少括号     // Uncaught SyntaxError: Unexpected string</p>
<p>3, ReferenceError 对象</p>
<p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>
<p>错误场景：</p>
<p>​	引用一个不存在的变量时发生的错误。</p>
<p>​	将一个值分配给无法分配的对象，比如对函数的运行结果赋值</p>
<p>4，<code>RangeError</code>对象是一个值超出有效范围时发生的错误</p>
<p>数组长度为负数     // Uncaught RangeError: Invalid array length</p>
<p><code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值</p>
<p>5，<code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。</p>
<p>对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。 // Uncaught TypeError: 123 is not a constructor</p>
<p>调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。  // Uncaught TypeError: obj.unknownMethod is not a function</p>
<p>如何查看这些错误？</p>
<p>添加断点</p>
<pre><code>var err1 = new Error('出错了！');
var err2 = new RangeError('出错了，变量超出有效范围！');
var err3 = new TypeError('出错了，变量类型无效！');

err1.message // &quot;出错了！&quot;
err2.message // &quot;出错了，变量超出有效范围！&quot;
err3.message // &quot;出错了，变量类型无效！&quot;
</code></pre>
<p>如何打断点</p>
<p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>
<pre><code>var x = -1;

if (x &lt;= 0) {
  throw new Error('x 必须为正数');
}
// Un
</code></pre>
<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>
<p><code>try...catch</code> 结构</p>
<p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>
<pre><code>try {
  throw new Error('出错了!');
} catch (e) {
  console.log(e.name + &quot;: &quot; + e.message);
  console.log(e.stack);
}
// Error: 出错了!
//   at &lt;anonymous&gt;:3:9
//   ...
</code></pre>
<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>
<pre><code>try {
  f();
} catch(e) {
  // 处理错误
}
</code></pre>
<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>
<pre><code>try {
  throw &quot;出错了&quot;;
} catch (e) {
  console.log(111);
}
console.log(222);
// 111
// 222
</code></pre>
<p><code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>
<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>
<pre><code>try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.log(e.name + &quot;: &quot; + e.message);
  } else if (e instanceof RangeError) {
    console.log(e.name + &quot;: &quot; + e.message);
  }
  // ...
}
</code></pre>
<h3 id="符号说明">符号说明</h3>
<p><code>()</code>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。</p>
<pre><code>// 圆括号表示函数的调用
console.log('abc');

// 圆括号表示表达式的组合
(1 + 2) * 3
</code></pre>
<p>规范</p>
<pre><code>表示函数调用时，函数名与左括号之间没有空格。

表示函数定义时，函数名与左括号之间没有空格。

其他情况时，前面位置的语法元素与左括号之间，都有一个空格。
</code></pre>
<p>变量符号</p>
<p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p>
<p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>。</p>
<ul>
<li>所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</li>
<li>不要使用<code>with</code>语句。</li>
<li>建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）。</li>
<li>建议不要将不同目的的语句，合并成一行。</li>
<li>所有的<code>++</code>运算符都可以用<code>+= 1</code>代替。</li>
<li>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替</li>
<li>建议<code>switch...case</code>结构可以用对象结构代替。</li>
</ul>
<p>重构switch方法</p>
<pre><code>function doAction(action) {
  switch (action) {
    case 'hack':
      return 'hack';
    case 'slash':
      return 'slash';
    case 'run':
      return 'run';
    default:
      throw new Error('Invalid action.');
  }
}
</code></pre>
<p>重构</p>
<pre><code>function doAction(action) {
  var actions = {
    'hack': function () {
      return 'hack';
    },
    'slash': function () {
      return 'slash';
    },
    'run': function () {
      return 'run';
    }
  };

  if (typeof actions[action] !== 'function') {
    throw new Error('Invalid action.');
  }

  return actions[action]();
}
</code></pre>
<h3 id="console">console</h3>
<p>常用方法</p>
<p><code>count</code>方法用于计数，输出它被调用了多少次。</p>
<pre><code>function greet(user) {
  console.count();
  return 'hi ' + user;
}

greet('bob')
//  : 1
// &quot;hi bob&quot;

greet('alice')
//  : 2
// &quot;hi alice&quot;

greet('bob')
//  : 3
// &quot;hi bob&quot;
</code></pre>
<p>检查对象</p>
<p><code>console.dir()</code>，<code>console.dirxml()</code></p>
<pre><code>console.log({f1: 'foo', f2: 'bar'})
// Object {f1: &quot;foo&quot;, f2: &quot;bar&quot;}

console.dir({f1: 'foo', f2: 'bar'})
// Object
//   f1: &quot;foo&quot;
//   f2: &quot;bar&quot;
//   __proto__: Object
</code></pre>
<p>打断点</p>
<p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p>
<pre><code>console.assert(false, '判断条件不成立')
// Assertion failed: 判断条件不成立

// 相当于
try {
  if (!false) {
    throw new Error('判断条件不成立');
  }
} catch(e) {
  console.error(e);
}
</code></pre>
<p>代码计时</p>
<p><code>console.time()</code>，<code>console.timeEnd()</code></p>
<pre><code>console.time('Array initialize');

var array= new Array(1000000);
for (var i = array.length - 1; i &gt;= 0; i--) {
  array[i] = new Object();
};

console.timeEnd('Array initialize');
// Array initialize: 1914.481ms
</code></pre>
<p>代码查错</p>
<p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>
<pre><code>console.trace()
// console.trace()
//   (anonymous function)
//   InjectedScript._evaluateOn
//   InjectedScript._evaluateAndWrap
//   InjectedScript.evaluate
</code></pre>
<p><code>debugger 语句</code></p>
<p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>
<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>
<pre><code>for(var i = 0; i &lt; 5; i++){
  console.log(i);
  if (i === 2) debugger;
}
</code></pre>
<h3 id="object">Object</h3>
<p><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象</p>
<p>方法</p>
<p>属性描述对象</p>
<pre><code>{
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false,
  get: undefined,
  set: undefined
}
</code></pre>
<pre><code>value

value是该属性的属性值，默认为undefined。

（2）writable

writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。

（3）enumerable

enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。

（4）configurable

configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。

（5）get

get是一个函数，表示该属性的取值函数（getter），默认为undefined。

（6）set

set是一个函数，表示该属性的存值函数（setter），默认为undefined。
</code></pre>
<p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</p>
<pre><code>var obj = { p: 'a' };

Object.getOwnPropertyDescriptor(obj, 'p')
// Object { value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
</code></pre>
<p>注意，<code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性。</p>
<h4 id="对象的拷贝">对象的拷贝</h4>
<p>我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。</p>
<pre><code>var extend = function (to, from) {
  for (var property in from) {
    to[property] = from[property];
  }

  return to;
}

extend({}, {
  a: 1
})
// {a: 1}
</code></pre>
<p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值</p>
<pre><code>extend({}, {
  get a() { return 1 }
})
// {a: 1}
</code></pre>
<p>为了解决这个问题，我们可以通过<code>Object.defineProperty</code>方法来拷贝属性。</p>
<pre><code>var extend = function (to, from) {
  for (var property in from) {
    if (!from.hasOwnProperty(property)) continue;
    Object.defineProperty(
      to,
      property,
      Object.getOwnPropertyDescriptor(from, property)
    );
  }

  return to;
}

extend({}, { get a(){ return 1 } })
// { get a(){ return 1 } })
</code></pre>
<p>上面代码中，<code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象。</p>
<h4 id="控制对象状态">控制对象状态</h4>
<p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p>
<p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p>
<pre><code>var obj = new Object();
Object.preventExtensions(obj);

Object.defineProperty(obj, 'p', {
  value: 'hello'
});
// TypeError: Cannot define property:p, object is not extensible.

obj.p = 1;
obj.p // undefined
</code></pre>
<p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了。</p>
<p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性。</p>
<pre><code>var obj = new Object();

Object.isExtensible(obj) // true
Object.preventExtensions(obj);
Object.isExtensible(obj) // false上面代码中，对obj对象使用Object.preventExtensions方法以后，再使用Object.isExtensible方法，返回false，表示已经不能添加新属性了。
</code></pre>
<p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了。</p>
<p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。</p>
<pre><code>var obj = { p: 'hello' };
Object.seal(obj);

delete obj.p;
obj.p // &quot;hello&quot;

obj.x = 'world';
obj.x // undefined
</code></pre>
<p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了。</p>
<p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</p>
<pre><code>var obj = {
  p: 'a'
};

// seal方法之前
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

Object.seal(obj);

// seal方法之后
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: false
// }

Object.defineProperty(obj, 'p', {
  enumerable: false
})
// TypeError: Cannot redefine property: p
</code></pre>
<p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错。</p>
<p><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值。</p>
<pre><code>var obj = { p: 'a' };
Object.seal(obj);
obj.p = 'b';
obj.p // 'b'
</code></pre>
<p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定。</p>
<p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p>
<pre><code>var obj = { p: 'a' };

Object.seal(obj);
Object.isSealed(obj) // true
</code></pre>
<p>这时，<code>Object.isExtensible</code>方法也返回<code>false</code>。</p>
<pre><code>var obj = { p: 'a' };

Object.seal(obj);
Object.isExtensible(obj) // false
</code></pre>
<p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);

obj.p = 'world';
obj.p // &quot;hello&quot;

obj.t = 'hello';
obj.t // undefined

delete obj.p // false
obj.p // &quot;hello&quot;
</code></pre>
<p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。</p>
<p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);
Object.isFrozen(obj) // true
</code></pre>
<p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);

Object.isSealed(obj) // true
Object.isExtensible(obj) // false
</code></pre>
<p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p>
<pre><code>var obj = {
  p: 'hello'
};

Object.freeze(obj);

if (!Object.isFrozen(obj)) {
  obj.p = 'world';
}
</code></pre>
<p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了。</p>
<h3 id="构造函数">构造函数</h3>
<p><code>Array</code>是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<pre><code>var arr = new Array(2);
arr.length // 2
arr // [ empty x 2 ]
</code></pre>
<p><code>Array()</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>
<pre><code>// bad
var arr = new Array(1, 2);

// good
var arr = [1, 2];
</code></pre>
<p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足。</p>
<pre><code>var arr = [1, 2, 3];

typeof arr // &quot;object&quot;
Array.isArray(arr) // true
</code></pre>
<p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组。</p>
<p><code>push</code>方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<pre><code>var arr = [];

arr.push(1) // 1
arr.push('a') // 2
arr.push(true, {}) // 4
arr // [1, 'a', true, {}]
</code></pre>
<p>上面代码使用<code>push</code>方法，往数组中添加了四个成员。</p>
<p><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<pre><code>var arr = ['a', 'b', 'c'];

arr.pop() // 'c'
arr // ['a', 'b']
</code></pre>
<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</p>
<pre><code>var arr = [];
arr.push(1, 2);
arr.push(3);
arr.pop();
arr // [1, 2]
</code></pre>
<p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组。</p>
<ul>
<li><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</li>
<li>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象。</li>
<li><code>concat</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</li>
<li><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</li>
<li><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变。<code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</li>
<li><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</li>
<li><code>map()</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</li>
<li><code>forEach()</code>方法与<code>map()</code>方法很相似，也是对数组的所有成员依次执行参数函数。</li>
<li><code>filter()</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</li>
<li><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</li>
<li><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</li>
<li><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</li>
</ul>
<h3 id="正则表达式">正则表达式</h3>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<pre><code>var regex = /xyz/;
</code></pre>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<pre><code>var regex = new RegExp('xyz');
</code></pre>
<h4 id="匹配规则"><a href="https://wangdoc.com/javascript/stdlib/regexp.html#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99">匹配规则</a></h4>
<p>字面量字符和元字符</p>
<p><code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<pre><code>/dog/.test('old dog') // true
</code></pre>
<p><code>元字符</code></p>
<p><strong>点字符（.)</strong></p>
<p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<pre><code>/c.t/
</code></pre>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code></p>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<pre><code>// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false
</code></pre>
<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<pre><code>/11|22/.test('911') // true
</code></pre>
<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p>多个选择符可以联合使用。</p>
<pre><code>// 匹配fred、barney、betty之中的一个
/fred|barney|betty/
</code></pre>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<pre><code>/a( |\t)b/.test('a\tb') // true
</code></pre>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文解释。</p>
<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<h3 id="json对象">JSON对象</h3>
<p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式</p>
<p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值</p>
<p>以下都是合法的 JSON。</p>
<pre><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]

{ &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 }

{&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] }

[ { &quot;name&quot;: &quot;张三&quot;}, {&quot;name&quot;: &quot;李四&quot;} ]
</code></pre>
<p>以下都是不合法的 JSON。</p>
<pre><code>{ name: &quot;张三&quot;, 'age': 32 }  // 属性名必须使用双引号

[32, 64, 128, 0xFFF] // 不能使用十六进制值

{ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined } // 不能使用 undefined

{ &quot;name&quot;: &quot;张三&quot;,
  &quot;birthday&quot;: new Date('Fri, 26 Aug 2011 07:13:10 GMT'),
  &quot;getName&quot;: function () {
      return this.name;
  }
} // 属性值不能使用函数和日期对象
</code></pre>
<p>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值。</p>
<p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>。</p>
<h3 id="面向对象">面向对象</h3>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#javascript%E6%8E%92%E9%94%99">JavaScript排错</a></li>
<li><a href="#%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">符号说明</a></li>
<li><a href="#console">console</a></li>
<li><a href="#object">Object</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D">对象的拷贝</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81">控制对象状态</a></li>
</ul>
</li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>
<ul>
<li><a href="#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99">匹配规则</a></li>
</ul>
</li>
<li><a href="#json%E5%AF%B9%E8%B1%A1">JSON对象</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://cosmoslazycat.github.io/post/fan-yi-ru-he-nu-li-gong-zuo/">
              <h3 class="post-title">
                [翻译]如何努力工作
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://cosmoslazycat.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
